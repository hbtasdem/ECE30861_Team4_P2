#!/usr/bin/env python3
"""ECE 461 Model Scorer - TA-compliant executable script."""

import os
import subprocess
import sys


def install_dependencies() -> int:
    """Install dependencies using pip install --user."""
    try:
        # Install from requirements.txt
        result = subprocess.run([
            sys.executable, "-m", "pip", "install", "--user", "-r",
            "requirements.txt"
        ], capture_output=True, text=True)

        if result.returncode == 0:
            print("Dependencies installed successfully")
            return 0
        else:
            print(f"Error installing dependencies: {result.stderr}")
            return 1
    except Exception as e:
        print(f"Error: {e}")
        return 1


def process_urls(url_file: str) -> int:
    """Process CSV file with code, dataset, and model links."""
    try:
        # Import our main processing function
        sys.path.append('phase1metrics')
        import contextlib
        import csv
        import io
        import json

        from phase1metrics.main import calculate_all_scores

        with open(url_file, 'r', encoding='utf-8') as f:
            content = f.read().strip()

        # Parse CSV content
        csv_reader = csv.reader(io.StringIO(content))
        
        # Track encountered datasets and code across all models
        encountered_datasets = set()
        encountered_code = set()

        for row in csv_reader:
            if not row:
                continue

            # Handle rows with fewer than 3 columns by padding with empty
            # strings
            while len(row) < 3:
                row.append("")

            code_link = row[0].strip() if row[0] else ""
            dataset_link = row[1].strip() if row[1] else ""
            model_link = row[2].strip() if row[2] else ""

            # Skip rows where all fields are empty
            if not any([code_link, dataset_link, model_link]):
                continue

            # Only process rows that have a model link
            if model_link:
                # Suppress debug prints by redirecting stdout temporarily
                stdout_capture = io.StringIO()
                with contextlib.redirect_stdout(stdout_capture):
                    result = calculate_all_scores(code_link, dataset_link,
                                                  model_link, encountered_datasets,
                                                  encountered_code)

                print(json.dumps(result, separators=(',', ':')))

        return 0
    except Exception as e:
        print(f"Error processing URLs: {e}", file=sys.stderr)
        return 1


# GEORGIA I replaced previous run_tests with one by chatGPT
def run_tests() -> int:
    """Run the test suite and report coverage safely."""
    import subprocess
    import sys
    import re

    passed = 0
    failed = 0
    skipped = 0
    coverage = 0

    try:
        # Start pytest subprocess
        proc = subprocess.Popen(
            [sys.executable, "-m", "pytest", "tests/",
             "--cov=phase1metrics", "--cov-report=term", "--tb=short"],
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True
        )

        # Read output incrementally to avoid buffer blocking
        output_lines = []
        for line in proc.stdout:
            output_lines.append(line)

        proc.wait(timeout=60)  # 1 minute timeout

        output = "".join(output_lines)

        # Parse test counts
        passed_match = re.search(r'(\d+)\s+passed', output)
        if passed_match:
            passed = int(passed_match.group(1))

        failed_match = re.search(r'(\d+)\s+failed', output)
        if failed_match:
            failed = int(failed_match.group(1))

        skipped_match = re.search(r'(\d+)\s+skipped', output)
        if skipped_match:
            skipped = int(skipped_match.group(1))

        total = passed + failed + skipped

        # Parse coverage
        coverage_match = re.search(r'TOTAL.*?(\d+)%', output)
        if coverage_match:
            coverage = int(coverage_match.group(1))

        print(f"{passed}/{total} test cases passed. {coverage}% line coverage achieved.")
        return 0 if failed == 0 else 1

    except subprocess.TimeoutExpired:
        proc.kill()
        print("Tests timed out", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"Error running tests: {e}", file=sys.stderr)
        return 1


def validate_environment() -> int:
    """Validate required environment variables at startup."""
    
    # Check GITHUB_TOKEN - simple validation
    github_token = os.getenv("GITHUB_TOKEN")
    if github_token is not None:
        if not github_token or github_token.strip() == "" or github_token == "invalid":
            print("Error: Invalid GITHUB_TOKEN", file=sys.stderr)
            return 1
    
    # Check LOG_FILE - simple validation (don't create files)
    log_file = os.getenv("LOG_FILE")
    if log_file is not None:
        if not os.path.exists(log_file):
            print(f"Error: Log file does not exist: {log_file}", file=sys.stderr)
            return 1
    
    # Check LOG_LEVEL
    log_level = os.getenv("LOG_LEVEL")
    if log_level is not None:
        try:
            level = int(log_level)
            if level < 0 or level > 2:
                print(f"Error: LOG_LEVEL must be 0, 1, or 2, got: {level}", file=sys.stderr)
                return 1
        except ValueError:
            print(f"Error: LOG_LEVEL must be an integer, got: {log_level}", file=sys.stderr)
            return 1
    
    return 0


def main() -> int:
    """Main CLI entry point."""
    # Validate environment variables first
    validation_result = validate_environment()
    if validation_result != 0:
        return validation_result

    if len(sys.argv) < 2:
        print("Usage: ./run <command>")
        print("Commands:")
        print("  install - Install dependencies")
        print("  test - Run test suite")
        print("  <url_file> - Process URLs from file")
        return 1

    command = sys.argv[1]

    if command == "install":
        return install_dependencies()
    elif command == "test":
        return run_tests()
    else:
        # Assume it's a URL file
        if os.path.exists(command):
            return process_urls(command)
        else:
            print(f"Error: File '{command}' not found", file=sys.stderr)
            return 1


if __name__ == "__main__":
    sys.exit(main())