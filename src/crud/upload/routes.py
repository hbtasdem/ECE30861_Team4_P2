"""HTTP API endpoint routes for Phase 2 model registration and retrieval.

Per OpenAPI v3.4.4 Section 3.2 - Artifact CRUD Endpoints

Implements 3 core API endpoints:
- POST /api/models/upload: Register model from URL (HTTP 200)
- GET /api/models/enumerate: List all registered models with pagination (HTTP 200)
- GET /api/models/{id}/download-redirect: Get model download URL (HTTP 200)

Key Features:
- URL-based model registration (no file upload)
- Artifact metadata extraction from URL
- Pagination support (skip/limit)
- Full audit trail of registrations
- JWT authentication via X-Authorization header
- ULID-based artifact IDs (strings, not integers)

Request Parameters:
- name: Human-readable model name
- model_url: URL to model artifact (https:// or http://)
- description: Optional model description
- version: Model version (default: 1.0.0)
- artifact_type: Type classification (default: model)
- is_sensitive: Sensitivity flag (default: false)

Response Structure:
- UploadResponse: {message, model_id, model_url, artifact_type}
- ModelResponse[]: Array of artifact objects with full metadata
- DownloadRedirectResponse: {download_url}

HTTP Status Codes:
- 200 OK: Successful operation (upload, enumerate, download-redirect)
- 400 Bad Request: Invalid URL format (missing http/https scheme)
- 404 Not Found: Model ID not found in database
- 422 Unprocessable Entity: Validation error (missing required fields)
- 500 Internal Server Error: Database or processing error

Authentication:
- X-Authorization header required for all endpoints (per spec)
- Bearer token format: X-Authorization: bearer <JWT>
- Token generated by PUT /authenticate endpoint

Error Validation:
- Empty model_url rejected (400)
- Non-http(s) schemes rejected (400)
- Missing required fields trigger 422
- Invalid pagination parameters handled gracefully

Spec Sections Referenced:
- Section 3.2.1: Artifact object structure and envelope
- Section 3.2.2: User authentication and authorization
- Section 3.1: Authentication endpoint (/authenticate)
"""

from typing import Any, Dict, List, Optional

from fastapi import (APIRouter, Depends, Form,  # UPDATED: Added Header import
                     Header, HTTPException, status)
from sqlalchemy.orm import Session

from src.crud.upload.artifacts import ModelCreate  # noqa: E402
from src.crud.upload.artifacts import ModelResponse, UploadResponse
from src.crud.upload.auth import get_current_user  # noqa: E402
from src.crud.upload.model_repository import ModelRepository  # noqa: E402
from src.database import get_db  # noqa: E402


# UPDATED: Helper function for getting current user with authorization header
async def get_current_user_with_auth(
    x_authorization: Optional[str] = Header(None),
    db: Session = Depends(get_db)
) -> Any:
    """Helper to pass x_authorization header to get_current_user."""
    return get_current_user(authorization=x_authorization, db=db)


router = APIRouter(prefix="/api/models", tags=["models"])


@router.post("/upload", response_model=UploadResponse)
async def upload_model(
    name: str = Form(..., description="Model name"),
    model_url: str = Form(..., description="URL to model artifact"),
    description: Optional[str] = Form(None),
    version: str = Form("1.0.0"),
    artifact_type: str = Form("model"),
    is_sensitive: bool = Form(False),
    metadata: Optional[str] = Form(None),
    current_user: Any = Depends(get_current_user_with_auth),  # UPDATED: Use helper function
    db: Session = Depends(get_db)
) -> UploadResponse:
    """Register a model via URL"""
    # Validate URL
    if model_url == "":
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="model_url cannot be empty"
        )

    if not model_url.startswith(("https://", "http://")):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="model_url must start with https:// or http://"
        )

    model_data = ModelCreate(
        name=name,
        url=model_url
    )

    model_repo = ModelRepository(db)
    try:
        db_model = model_repo.create_model(
            model_data=model_data,
            uploader_id=current_user.id
        )

        # Metadata support removed - simplified schema per spec
        # if metadata:
        #     try:
        #         metadata_dict = json.loads(metadata)
        #         model_repo.add_model_metadata(db_model.id, metadata_dict)
        #     except json.JSONDecodeError:
        #         pass

        return UploadResponse(
            message="Model registered successfully",
            model_id=db_model.id,  # ID is now a string per spec
            model_url=model_data.url,  # Use url field from ModelCreate
            artifact_type=artifact_type
        )
    except Exception as e:
        import traceback
        traceback.print_exc()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to register model: {str(e)}"
        )


@router.get("/{model_id}/download-redirect")
async def get_download_url(
    model_id: str,
    db: Session = Depends(get_db)
) -> Dict[str, str]:
    """Get download redirect URL for a model."""
    model_repo = ModelRepository(db)
    model = model_repo.get_model_by_id(model_id)

    if not model:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Model with id {model_id} not found"
        )

    if not model.url:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Model does not have a URL"
        )

    return {"download_url": str(model.url)}


@router.get("/enumerate", response_model=List[ModelResponse])
async def enumerate_models(
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db)
) -> List[ModelResponse]:
    """Enumerate all registered models with pagination.

    Args:
        skip: Number of models to skip (default: 0)
        limit: Maximum number of models to return (default: 100, max: 1000)

    Returns:
        List of ModelResponse objects
    """
    # Enforce maximum limit to prevent abuse
    if limit > 1000:
        limit = 1000

    if skip < 0:
        skip = 0

    model_repo = ModelRepository(db)
    models = model_repo.get_all_models(skip=skip, limit=limit)
    return [ModelResponse.model_validate(model) for model in models]
