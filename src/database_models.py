"""SQLAlchemy ORM models - OpenAPI v3.4.4 BASELINE schema implementation.

Per OpenAPI v3.4.4 Sections 3.2 - 3.3 - Complete Database Schema

FILE PURPOSE:
Defines complete database schema for all phases of artifact management.
Implements Phase 2 baseline (User, Artifact, AuditEntry) and provides foundation for future phases.
All models use SQLAlchemy declarative syntax with comprehensive documentation.

SCHEMA OVERVIEW:

┌──────────────┐         ┌────────────────┐         ┌──────────────────┐
│   User       │───1:N───│   Artifact     │───1:N───│   AuditEntry     │
│              │         │                │         │                  │
├──────────────┤         ├────────────────┤         ├──────────────────┤
│ id (PK)      │         │ id (PK,STRING) │         │ id (PK)          │
│ username     │         │ name           │         │ user_id (FK)     │
│ email        │         │ type           │         │ artifact_id (FK) │
│ hashed_pass  │         │ url            │         │ action           │
│ is_admin     │         │ download_url   │         │ timestamp        │
│ created_at   │         │ uploader_id    │         │                  │
└──────────────┘         │ created_at     │         └──────────────────┘
                         │ updated_at     │
                         └────────────────┘

SPEC COMPLIANCE BY TABLE:

1. USER TABLE (Section 3.2.2)
   Purpose: User authentication and audit trail tracking
   Spec Requirement: Per Section 3.2.2 - User object definition

   Columns:
   - id (Integer, PK): Auto-increment user ID (1, 2, 3, ...)
   - username (String): Unique login identifier
   - email (String): Unique email address
   - hashed_password (String): Bcrypt-hashed password
     * Per spec: Password stored as bcrypt hash (not plaintext)
     * Security: 12 rounds, constant-time comparison
     * Limit: 72 bytes per bcrypt specification
   - is_admin (Boolean): Admin privilege flag
     * Per spec: Determines access to admin endpoints (e.g., DELETE /reset)
     * Default: False
   - created_at (DateTime): Account creation timestamp

   Relationships:
   - artifacts (1:N): One-to-many with Artifact table
   - audit_entries (1:N): One-to-many with AuditEntry table

   Constraints:
   - username UNIQUE NOT NULL
   - email UNIQUE NOT NULL
   - hashed_password NOT NULL

2. ARTIFACT TABLE (Section 3.2.1 - CRITICAL)
   Purpose: Store artifact metadata and source URLs
   Spec Requirement: Per Section 3.2.1 - Artifact object with envelope structure

   Columns:
   - id (String, PK): CRITICAL CHANGE FROM PHASE 1
     * Phase 1: Integer (1, 2, 3, ...)
     * Phase 2: String (ULID format)
     * Pattern: "^[a-zA-Z0-9\\-]+$"
     * Example: "01K9ZBPCEQM0CK4X2T984FX8CS"
     * Why ULID: Sortable by creation time, globally unique, distributed-friendly
     * Generated by: ULID() function in routes.py

   - name (String): Artifact name
     * Indexed for fast lookups in GET /artifact/byName/{name}
     * Auto-extracted from source URL (e.g., "bert-base-uncased" from HuggingFace URL)
     * Used in responses and audit trails

   - type (String): Artifact classification
     * MUST be one of: 'model', 'dataset', 'code'
     * Per spec: CHECK (type IN ('model', 'dataset', 'code'))
     * Constraint: Database-level validation
     * Used for routing: GET /artifacts/{type}/{id}

   - url (String): Source URL where artifact originated
     * Per spec Section 3.2.1: "Artifact source url used during ingest"
     * Example: "https://huggingface.co/models/bert-base-uncased"
     * Required: NOT NULL (every artifact must have a source)
     * Used by: Artifact verification and provenance tracking

   - download_url (String): Server-provided download URL
     * Per spec: Our server's URL for downloading artifact
     * Format: "/api/artifacts/{type}/{id}/download"
     * Auto-generated: Set during artifact creation
     * Read-only in responses

   - uploader_id (Integer, FK): Foreign key to User table
     * Per spec: Tracks who uploaded the artifact
     * Used for: Audit logging and access control
     * CASCADE: On user deletion, artifacts may be deleted

   - created_at (DateTime): Artifact creation timestamp
     * Set automatically to UTC now() on insert
     * Used for: Sorting and filtering in enumerate endpoints

   - updated_at (DateTime): Last modification timestamp
     * Set automatically to UTC now() on insert and update
     * Used for: Tracking modification history
     * Per spec: Updated when artifact metadata changes

   Relationships:
   - uploader (1:1): Many-to-one with User table
   - audit_entries (1:N): One-to-many with AuditEntry table

   Constraints:
   - type CHECK (must be model/dataset/code)
   - id PRIMARY KEY (String)
   - uploader_id FOREIGN KEY (must exist in users.id)

3. AUDIT_ENTRY TABLE (Section 3.2.1 - Future Use)
   Purpose: Track all artifact mutations for compliance and auditing
   Spec Requirement: Used by future endpoint GET /artifact/{type}/{id}/audit

   Columns:
   - id (Integer, PK): Auto-increment entry ID
   - artifact_id (String, FK): Reference to Artifact being audited
   - user_id (Integer, FK): User who performed action
   - action (String): Type of mutation
     * Values: CREATE, UPDATE, DOWNLOAD, RATE, AUDIT
     * Per spec: Different actions may have different permissions
     * Extensible: Can add DELETE, SHARE, etc. in future
   - timestamp (DateTime): ISO-8601 UTC datetime of action
     * Set automatically to UTC now() on insert
     * Used for: Chronological ordering of mutations

   Relationships:
   - artifact (N:1): Many-to-one with Artifact table
   - user (N:1): Many-to-one with User table

   Spec Reference:
   - Section 3.2.1: "Audit trail of all artifact mutations"
   - Section 3.4: Future endpoint /artifact/{type}/{id}/audit
   - Per spec: Enables compliance, usage tracking, security auditing

ARTIFACT ID MIGRATION (Phase 1 → Phase 2):

Phase 1 (Old):
  - id: Integer (1, 2, 3, ...)
  - Problem: Not suitable for distributed systems
  - Problem: Guessable artifact IDs

Phase 2 (Current):
  - id: String with ULID format
  - Solution: Cryptographically secure IDs
  - Solution: Sortable by creation time
  - Solution: Works in distributed environments

Breaking Change:
  - Queries must use string IDs: db.query(Artifact).filter(Artifact.id == "01K9ZBPCEQM0CK4X2T984FX8CS")
  - Type changed: String, not Integer
  - Migration: Old integer IDs must be converted to strings

EXAMPLE ARTIFACT:
{
  "id": "01K9ZBPCEQM0CK4X2T984FX8CS",           # ULID string
  "name": "bert-base-uncased",                  # From URL
  "type": "model",                              # Classification
  "url": "https://huggingface.co/models/...",  # Source
  "download_url": "/api/artifacts/model/01K9ZBPCEQM0CK4X2T984FX8CS/download",
  "uploader_id": 42,                            # User ID
  "created_at": "2024-01-15T10:30:00Z",        # ISO-8601
  "updated_at": "2024-01-15T10:30:00Z"
}

ENUM TYPES (Suggested for future enhancements):

ArtifactType = Enum('model', 'dataset', 'code')

AuditAction = Enum(
  'CREATE',      # Artifact registered
  'UPDATE',      # Metadata or URL changed
  'DOWNLOAD',    # Artifact downloaded
  'RATE',        # Artifact rated
  'AUDIT',       # Audit trail queried
  'DELETE',      # Artifact deleted
  'SHARE'        # Shared with other users
)

SPEC SECTIONS REFERENCED:
- Section 3.2.1: Artifact object structure and envelope format
- Section 3.2.2: User authentication schema
- Section 3.3: Database constraints and relationships
- Section 3.1: Authentication flow

FUTURE EXTENSIONS (Phase 5+):
- Tags table: Many-to-many artifact tags
- Rating table: User ratings and reviews
- Download_log table: Detailed download tracking
- Version_history table: Artifact version tracking
"""

from datetime import datetime

from sqlalchemy import Boolean, CheckConstraint, Column, DateTime, ForeignKey, Integer, String
from sqlalchemy.orm import declarative_base, relationship

Base = declarative_base()


class User(Base):  # type: ignore
    """User account for authentication per OpenAPI spec.

    Per Spec Section 3.2.2 - User object:
    - name: Username or email (String)
    - is_admin: Admin flag for access control (Boolean)
    - Also stores hashed password (not in spec but required)

    Table: users
    Primary Key: id (Integer)
    """

    __tablename__ = "users"

    # ========================================================================
    # PRIMARY KEY & UNIQUE IDENTIFIERS
    # ========================================================================
    id = Column(Integer, primary_key=True)

    # ========================================================================
    # USER CREDENTIALS & METADATA
    # ========================================================================
    # username: Unique login identifier
    username = Column(String(255), unique=True, nullable=False)

    # email: User email (also unique per spec requirements)
    email = Column(String(255), unique=True, nullable=False)

    # hashed_password: Bcrypt-hashed password (NOT in spec, internal requirement)
    # Per spec: password in AuthenticationRequest is hashed before storage
    hashed_password = Column(String(255), nullable=False)

    # is_admin: Admin flag for access control (per spec User object)
    # Determines if user can access admin endpoints like DELETE /reset
    is_admin = Column(Boolean, default=False)

    # ========================================================================
    # TRACKING & TIMESTAMPS
    # ========================================================================
    # created_at: Account creation timestamp
    created_at = Column(DateTime, default=datetime.utcnow)

    # ========================================================================
    # RELATIONSHIPS
    # ========================================================================
    # artifacts: One-to-many relationship with Artifact table
    # Represents artifacts uploaded by this user (uploader_id foreign key)
    artifacts = relationship("Artifact", back_populates="uploader")

    # audit_entries: One-to-many relationship with AuditEntry table
    # Tracks all mutations performed by this user
    audit_entries = relationship("AuditEntry", back_populates="user")


class Artifact(Base):  # type: ignore
    """Artifact entity - OpenAPI v3.4.4 spec compliant.

    Per Spec Section 3.2.1 - Artifact object with envelope structure:

    METADATA SECTION (identifies the artifact):
    - name: Human-readable artifact name (String)
    - id: Unique string identifier (String, primary key)
    - type: Artifact classification (Enum: model, dataset, code)

    DATA SECTION (points to the artifact):
    - url: Source URL where artifact originated (e.g., GitHub)
    - download_url: Our server's URL for downloading artifact

    TRACKING & RELATIONSHIPS:
    - uploader_id: Foreign key to User who uploaded it
    - created_at: ISO-8601 timestamp of creation
    - updated_at: ISO-8601 timestamp of last modification
    - audit_entries: Audit trail of all mutations

    Table: artifacts
    Primary Key: id (String, not Integer!)
    Constraints: type must be one of {model, dataset, code}
    """

    __tablename__ = "artifacts"

    # ========================================================================
    # METADATA SECTION (Per Spec Section 3.2.1)
    # ========================================================================
    # id: CRITICAL CHANGE - String instead of Integer
    #   - Spec requirement: "Artifact ID must be a string"
    #   - Pattern: "^[a-zA-Z0-9\\-]+$"
    #   - Examples: "3847247294" or "550e8400-e29b-41d4-a716-446655440000"
    #   - Generated using ULID or UUID (see crud/upload/routes.py)
    #   - This is the PRIMARY KEY of the table
    id = Column(String(255), primary_key=True)

    # name: Artifact name
    #   - Indexed for fast lookups (GET /artifact/byName/{name})
    #   - Used in audit trails and lineage graphs
    name = Column(String(255), nullable=False, index=True)

    # artifact_type: Artifact classification per spec
    #   - MUST be one of: 'model', 'dataset', 'code'
    #   - NOT nullable - every artifact must have a type
    #   - Used for routing (GET /artifacts/{type}/{id})
    #   - Checked by constraint defined below
    type = Column(String(20), nullable=False)

    # ========================================================================
    # DATA SECTION (Per Spec Section 3.2.1)
    # ========================================================================
    # url: Source URL where artifact originated
    #   - Example: "https://huggingface.co/models/bert-base-uncased"
    #   - Used for verification and tracking provenance
    #   - NOT nullable
    url = Column(String(2048), nullable=False)

    # download_url: Our server's URL for downloading the artifact
    #   - Generated by our system (e.g., "/download/{artifact_id}")
    #   - Used in responses to direct users to artifact retrieval
    #   - NOT nullable
    download_url = Column(String(2048), nullable=False)

    # ========================================================================
    # TRACKING & RELATIONSHIPS
    # ========================================================================
    # uploader_id: Foreign key to User who uploaded this artifact
    #   - Per spec: Artifacts are uploaded by authenticated users
    #   - Used to track artifact ownership and access control
    uploader_id = Column(Integer, ForeignKey("users.id"), nullable=False)

    # created_at: ISO-8601 creation timestamp
    #   - Set automatically to UTC now() on insert
    #   - Used for sorting and filtering in enumerate endpoints
    created_at = Column(DateTime, default=datetime.utcnow)

    # updated_at: ISO-8601 last modification timestamp
    #   - Set automatically to UTC now() on insert and update
    #   - Used for tracking when artifact was last modified
    #   - Per spec: Modifications tracked in audit trail
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # ========================================================================
    # RELATIONSHIPS (SQLAlchemy)
    # ========================================================================
    # uploader: Relationship to User object
    #   - Allows accessing user info from artifact: artifact.uploader.username
    uploader = relationship("User", back_populates="artifacts")

    # audit_entries: One-to-many relationship with AuditEntry
    #   - Per spec: GET /artifact/{type}/{id}/audit returns these entries
    #   - cascade='all, delete-orphan' ensures cleanup on artifact deletion
    audit_entries = relationship(
        "AuditEntry", back_populates="artifact", cascade="all, delete-orphan"
    )

    # ========================================================================
    # TABLE CONSTRAINTS (Per Spec Requirements)
    # ========================================================================
    # CheckConstraint: Enforce that type is valid per spec
    #   - Spec allows ONLY: 'model', 'dataset', 'code'
    #   - Database-level constraint prevents invalid data entry
    #   - Per spec: "type must be one of model, dataset, or code"
    __table_args__ = (CheckConstraint("type IN ('model', 'dataset', 'code')"),)


class AuditEntry(Base):  # type: ignore
    """Audit trail entry for tracking artifact mutations.

    Per Spec Section 3.X - Audit trail requirements:

    Each mutation of an artifact creates an AuditEntry recording:
    - WHAT happened: action (CREATE, UPDATE, DOWNLOAD, RATE, AUDIT)
    - WHO did it: user_id (reference to User)
    - WHEN it happened: timestamp (ISO-8601 UTC)
    - WHICH artifact: artifact_id (reference to Artifact)

    Used by endpoint: GET /artifact/{type}/{id}/audit
    Returns paginated list of AuditEntry objects showing mutation history.

    Per Spec: Actions are:
    - CREATE: Artifact registered in system
    - UPDATE: Artifact metadata or URL changed
    - DOWNLOAD: Artifact downloaded by user
    - RATE: Artifact was rated (per scoring endpoints)
    - AUDIT: User queried audit trail

    Table: audit_entries
    Primary Key: id (Integer, auto-increment)
    Indexes: (artifact_id, timestamp) for efficient audit queries
    """

    __tablename__ = "audit_entries"

    # ========================================================================
    # PRIMARY KEY
    # ========================================================================
    # id: Auto-increment primary key
    #   - Used for internal tracking only
    #   - Not exposed in API responses
    id = Column(Integer, primary_key=True)

    # ========================================================================
    # FOREIGN KEYS (References to Artifact and User)
    # ========================================================================
    # artifact_id: Reference to the Artifact being audited
    #   - Must match an id in artifacts table
    #   - Per spec: Audit entries are tied to specific artifacts
    #   - String type to match Artifact.id (see above)
    artifact_id = Column(String(255), ForeignKey("artifacts.id"), nullable=False)

    # user_id: Reference to the User who performed action
    #   - Must match an id in users table
    #   - Per spec: Track WHO performed each action
    #   - Enables access control and usage tracking
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)

    # ========================================================================
    # ACTION & TIMESTAMP
    # ========================================================================
    # action: Type of mutation that occurred
    #   - MUST be one of: 'CREATE', 'UPDATE', 'DOWNLOAD', 'RATE', 'AUDIT'
    #   - Per spec: Different actions may have different permissions
    #   - Stored as string for flexibility
    action = Column(String(20), nullable=False)

    # timestamp: ISO-8601 UTC datetime of the action
    #   - Set automatically to UTC now() on insert
    #   - Used for sorting audit entries chronologically
    #   - Per spec: Used in GET /artifact/{type}/{id}/audit response
    timestamp = Column(DateTime, default=datetime.utcnow)

    # ========================================================================
    # RELATIONSHIPS (SQLAlchemy)
    # ========================================================================
    # artifact: Reference to the Artifact object being audited
    #   - Allows: audit_entry.artifact.name, audit_entry.artifact.type, etc.
    artifact = relationship("Artifact", back_populates="audit_entries")

    # user: Reference to the User who performed the action
    #   - Allows: audit_entry.user.username, audit_entry.user.is_admin, etc.
    user = relationship("User", back_populates="audit_entries")
